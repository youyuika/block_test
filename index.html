<!doctype html>
<html lang="zh-Hant">
  <head>
    <meta charset="UTF-8" />
    <title>ÊñπÊ†ºÂØ¶È©ó</title>
    <style>
      :root {
        --bg: #f0f2f5;
        --cell-size: 35px; /* Á®çÂæÆÁ∏ÆÂ∞è‰ª•ÈÅ©ÊáâÂ§ßÊ£ãÁõ§ */
        --color-I: #00bcd4;
        --color-T: #9c27b0;
        --color-Z: #f44336;
        --color-O: #ffeb3b;
        --color-L: #ff9800;
      }
      body {
        font-family: sans-serif;
        background: var(--bg);
        display: flex;
        flex-direction: column;
        align-items: center;
        padding: 10px;
      }
      .layout {
        display: flex;
        gap: 30px;
        margin-top: 15px;
        align-items: flex-start;
        flex-wrap: wrap;
        justify-content: center;
      }

      .grid {
        display: grid;
        background: #ccc;
        gap: 1px;
        border: 2px solid #333;
        padding: 1px;
        box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
      }
      .cell {
        width: var(--cell-size);
        height: var(--cell-size);
        background: white;
        transition: background 0.1s;
      }
      .cell.occupied {
        border: none;
      }
      .cell.preview {
        opacity: 0.5 !important;
      }

      .toolbar {
        background: white;
        padding: 20px;
        border-radius: 12px;
        box-shadow: 0 5px 20px rgba(0, 0, 0, 0.1);
        min-width: 250px;
      }
      .shape-slot {
        margin-bottom: 20px;
        display: flex;
        align-items: center;
        gap: 15px;
      }
      .shape-preview {
        display: grid;
        gap: 1px;
        cursor: grab;
        padding: 2px;
        border: 2px solid transparent;
        background: #f9f9f9;
      }
      .shape-preview:hover {
        border-color: #4a90e2;
        background: #fff;
      }
      .mini-cell {
        width: var(--cell-size);
        height: var(--cell-size);
      }

      .info-panel {
        min-width: 50px;
        text-align: center;
      }
      .count-badge {
        font-weight: bold;
        font-size: 1.4em;
        display: block;
        color: #333;
      }

      .btn-group {
        margin-bottom: 15px;
        display: flex;
        gap: 5px;
        flex-wrap: wrap;
        justify-content: center;
      }
      button {
        padding: 8px 12px;
        cursor: pointer;
        border-radius: 4px;
        border: 1px solid #ddd;
        background: white;
        font-weight: 500;
      }
      button.active {
        background: #4a90e2;
        color: white;
        border-color: #2a6dbd;
      }
      .reset-btn {
        background: #ff5252;
        color: white;
        border: none;
        margin-left: 10px;
      }

      .tip {
        font-size: 0.85em;
        color: #666;
        line-height: 1.6;
        margin-top: 10px;
        background: #fffde7;
        padding: 10px;
        border-radius: 5px;
      }
    </style>
  </head>
  <body>
    <h2 style="margin-bottom: 10px">ÊñπÊ†ºÂØ¶È©ó</h2>

    <div class="btn-group">
      <button onclick="changeSize(6)">6x6</button>
      <button onclick="changeSize(7)">7x7</button>
      <button onclick="changeSize(8)">8x8</button>
      <button onclick="changeSize(9)" class="active">9x9</button>
      <button onclick="changeSize(10)">10x10</button>
      <button onclick="changeSize(11)">11x11</button>
      <button class="reset-btn" onclick="location.reload()">
        ÈáçÁΩÆÊ£ãÁõ§ËàáÊï∏Èáè
      </button>
    </div>

    <div class="layout">
      <div class="toolbar">
        <div id="inventory"></div>
        <div class="tip">
          <b>Êìç‰ΩúÊåáÂçóÔºö</b><br />
          üñ±Ô∏è <b>Â∑¶ÈçµÈªûÊìäÔºö</b> È†ÜÊôÇÈáùÊóãËΩâ<br />
          üñ±Ô∏è <b>Âè≥ÈçµÈªûÊìäÔºö</b> Ê∞¥Âπ≥ÁøªËΩâ (Mirror)<br />
          üëÜ <b>ÊãñÁßªÂúñÊ°àÔºö</b> ÊîæÁΩÆÂà∞Ê£ãÁõ§
        </div>
      </div>
      <div id="grid" class="grid"></div>
    </div>

    <script>
      const SHAPES = {
        I: {
          color: "var(--color-I)",
          count: 3,
          cells: [
            [0, 0],
            [0, 1],
            [0, 2],
            [0, 3],
          ],
        },
        T: {
          color: "var(--color-T)",
          count: 6,
          cells: [
            [1, 0],
            [0, 1],
            [1, 1],
            [1, 2],
          ],
        },
        Z: {
          color: "var(--color-Z)",
          count: 4,
          cells: [
            [0, 0],
            [0, 1],
            [1, 1],
            [1, 2],
          ],
        },
        O: {
          color: "var(--color-O)",
          count: 4,
          cells: [
            [0, 0],
            [0, 1],
            [1, 0],
            [1, 1],
          ],
        },
        L: {
          color: "var(--color-L)",
          count: 4,
          cells: [
            [0, 0],
            [0, 1],
            [0, 2],
            [1, 2],
          ],
        }, // ÂàùÂßãÂ∑≤Ê∞¥Âπ≥ÁøªËΩâ
      };

      let currentSize = 9;
      let draggedType = null;
      let lastPreviewIndices = [];

      function initInventory() {
        const container = document.getElementById("inventory");
        container.innerHTML = "";
        for (let type in SHAPES) {
          const item = SHAPES[type];
          const div = document.createElement("div");
          div.className = "shape-slot";
          div.innerHTML = `
                    <div class="info-panel"><span class="count-badge" id="count-${type}">${item.count}</span><small>Ââ©È§ò</small></div>
                    <div id="preview-${type}" class="shape-preview" draggable="true" 
                         onclick="rotateShape('${type}')" 
                         oncontextmenu="flipShape(event, '${type}')"
                         ondragstart="handleDragStart(event, '${type}')">
                         ${renderShape(type)}
                    </div>
                `;
          container.appendChild(div);
        }
      }

      function renderShape(type) {
        const cells = SHAPES[type].cells;
        const maxR = Math.max(...cells.map((c) => c[0])) + 1;
        const maxC = Math.max(...cells.map((c) => c[1])) + 1;
        let html = `<div style="display:grid; grid-template-columns:repeat(${maxC}, var(--cell-size)); gap:1px; background:#eee;">`;
        for (let r = 0; r < maxR; r++) {
          for (let c = 0; c < maxC; c++) {
            const isPart = cells.some((cell) => cell[0] === r && cell[1] === c);
            html += `<div class="mini-cell" style="background:${isPart ? SHAPES[type].color : "transparent"}"></div>`;
          }
        }
        return html + `</div>`;
      }

      function rotateShape(type) {
        SHAPES[type].cells = SHAPES[type].cells.map((c) => [c[1], -c[0]]);
        normalize(type);
        document.getElementById(`preview-${type}`).innerHTML =
          renderShape(type);
      }

      function flipShape(e, type) {
        e.preventDefault();
        SHAPES[type].cells = SHAPES[type].cells.map((c) => [c[0], -c[1]]);
        normalize(type);
        document.getElementById(`preview-${type}`).innerHTML =
          renderShape(type);
      }

      function normalize(type) {
        const minR = Math.min(...SHAPES[type].cells.map((c) => c[0]));
        const minC = Math.min(...SHAPES[type].cells.map((c) => c[1]));
        SHAPES[type].cells = SHAPES[type].cells.map((c) => [
          c[0] - minR,
          c[1] - minC,
        ]);
      }

      function handleDragStart(e, type) {
        if (SHAPES[type].count <= 0) {
          e.preventDefault();
          return;
        }
        draggedType = type;
        const img = new Image();
        img.src =
          "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7";
        e.dataTransfer.setDragImage(img, 0, 0);
      }

      function renderGrid() {
        const grid = document.getElementById("grid");
        grid.style.gridTemplateColumns = `repeat(${currentSize}, var(--cell-size))`;
        grid.innerHTML = "";
        for (let i = 0; i < currentSize * currentSize; i++) {
          const cell = document.createElement("div");
          cell.className = "cell";
          cell.dataset.idx = i;
          cell.ondragover = handleDragOver;
          cell.ondragleave = clearPreview;
          cell.ondrop = handleDrop;
          grid.appendChild(cell);
        }
      }

      function getTargetIndices(startIdx) {
        const r0 = Math.floor(startIdx / currentSize);
        const c0 = startIdx % currentSize;
        const shape = SHAPES[draggedType];
        const indices = [];
        for (let [dr, dc] of shape.cells) {
          const r = r0 + dr;
          const c = c0 + dc;
          if (r >= currentSize || c >= currentSize || r < 0 || c < 0)
            return null;
          const idx = r * currentSize + c;
          if (
            document
              .querySelector(`[data-idx="${idx}"]`)
              .classList.contains("occupied")
          )
            return null;
          indices.push(idx);
        }
        return indices;
      }

      function handleDragOver(e) {
        e.preventDefault();
        clearPreview();
        const indices = getTargetIndices(parseInt(this.dataset.idx));
        if (indices) {
          indices.forEach((idx) => {
            const el = document.querySelector(`[data-idx="${idx}"]`);
            el.style.background = SHAPES[draggedType].color;
            el.classList.add("preview");
          });
          lastPreviewIndices = indices;
        }
      }

      function clearPreview() {
        lastPreviewIndices.forEach((idx) => {
          const el = document.querySelector(`[data-idx="${idx}"]`);
          if (!el.classList.contains("occupied")) {
            el.style.background = "";
            el.classList.remove("preview");
          }
        });
        lastPreviewIndices = [];
      }

      function handleDrop(e) {
        e.preventDefault();
        const indices = getTargetIndices(parseInt(this.dataset.idx));
        if (indices) {
          indices.forEach((idx) => {
            const el = document.querySelector(`[data-idx="${idx}"]`);
            el.style.background = SHAPES[draggedType].color;
            el.classList.add("occupied");
            el.classList.remove("preview");
          });
          SHAPES[draggedType].count--;
          document.getElementById(`count-${draggedType}`).innerText =
            SHAPES[draggedType].count;
          if (SHAPES[draggedType].count <= 0)
            document.getElementById(`preview-${draggedType}`).style.opacity =
              "0.2";
        }
        clearPreview();
      }

      function changeSize(s) {
        currentSize = s;
        document
          .querySelectorAll(".btn-group button")
          .forEach((b) => b.classList.remove("active"));
        const target = Array.from(
          document.querySelectorAll(".btn-group button"),
        ).find((b) => b.innerText.includes(s));
        if (target) target.classList.add("active");
        renderGrid();
      }

      initInventory();
      renderGrid();
    </script>
  </body>
</html>
